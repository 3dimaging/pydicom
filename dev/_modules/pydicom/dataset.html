

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pydicom.dataset &mdash; pydicom 1.3.0.dev0 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/pydicom.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/pydicom.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> pydicom
          

          
            
            <img src="../../_static/pydicom_flat_black.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                1.3.0.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting Started with pydicom</a></li>
</ul>
<p class="caption"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../pydicom_user_guide.html">Pydicom User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ref_guide.html">Reading and writing DICOM files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_ref.html">Pydicom Complete API Reference</a></li>
</ul>
<p class="caption"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../auto_examples/index.html">General examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../auto_examples/index.html#image-processing">Image processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../auto_examples/index.html#input-output">Input-output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../auto_examples/index.html#metadata-processing">Metadata processing</a></li>
</ul>
<p class="caption"><span class="caption-text">Additional Information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../release-notes.html">Release history</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pydicom</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>pydicom.dataset</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pydicom.dataset</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2008-2018 pydicom authors. See LICENSE file for details.</span>
<span class="sd">&quot;&quot;&quot;Define the Dataset and FileDataset classes.</span>

<span class="sd">The Dataset class represents the DICOM Dataset while the FileDataset class</span>
<span class="sd">adds extra functionality to Dataset when data is read from or written to file.</span>

<span class="sd">Overview of DICOM object model</span>
<span class="sd">------------------------------</span>
<span class="sd">Dataset (dict subclass)</span>
<span class="sd">  Contains DataElement instances, each of which has a tag, VR, VM and value.</span>
<span class="sd">    The DataElement value can be:</span>
<span class="sd">        * A single value, such as a number, string, etc. (i.e. VM = 1)</span>
<span class="sd">        * A list of numbers, strings, etc. (i.e. VM &gt; 1)</span>
<span class="sd">        * A Sequence (list subclass), where each item is a Dataset which</span>
<span class="sd">            contains its own DataElements, and so on in a recursive manner.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">inspect</span>  <span class="c1"># for __dir__</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">from</span> <span class="nn">bisect</span> <span class="k">import</span> <span class="n">bisect_left</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">takewhile</span>

<span class="kn">import</span> <span class="nn">pydicom</span>  <span class="c1"># for dcmwrite</span>
<span class="kn">import</span> <span class="nn">pydicom.charset</span>
<span class="kn">import</span> <span class="nn">pydicom.config</span>
<span class="kn">from</span> <span class="nn">pydicom</span> <span class="k">import</span> <span class="n">compat</span><span class="p">,</span> <span class="n">datadict</span>
<span class="kn">from</span> <span class="nn">pydicom._version</span> <span class="k">import</span> <span class="n">__version_info__</span>
<span class="kn">from</span> <span class="nn">pydicom.charset</span> <span class="k">import</span> <span class="n">default_encoding</span><span class="p">,</span> <span class="n">convert_encodings</span>
<span class="kn">from</span> <span class="nn">pydicom.config</span> <span class="k">import</span> <span class="n">logger</span>
<span class="kn">from</span> <span class="nn">pydicom.datadict</span> <span class="k">import</span> <span class="n">dictionary_VR</span>
<span class="kn">from</span> <span class="nn">pydicom.datadict</span> <span class="k">import</span> <span class="p">(</span><span class="n">tag_for_keyword</span><span class="p">,</span> <span class="n">keyword_for_tag</span><span class="p">,</span>
                              <span class="n">repeater_has_keyword</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pydicom.dataelem</span> <span class="k">import</span> <span class="n">DataElement</span><span class="p">,</span> <span class="n">DataElement_from_raw</span><span class="p">,</span> <span class="n">RawDataElement</span>
<span class="kn">from</span> <span class="nn">pydicom.pixel_data_handlers.util</span> <span class="k">import</span> <span class="p">(</span><span class="n">convert_color_space</span><span class="p">,</span>
                                              <span class="n">reshape_pixel_array</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pydicom.tag</span> <span class="k">import</span> <span class="n">Tag</span><span class="p">,</span> <span class="n">BaseTag</span><span class="p">,</span> <span class="n">tag_in_exception</span>
<span class="kn">from</span> <span class="nn">pydicom.uid</span> <span class="k">import</span> <span class="p">(</span><span class="n">ExplicitVRLittleEndian</span><span class="p">,</span> <span class="n">ImplicitVRLittleEndian</span><span class="p">,</span>
                         <span class="n">ExplicitVRBigEndian</span><span class="p">,</span> <span class="n">PYDICOM_IMPLEMENTATION_UID</span><span class="p">)</span>

<span class="k">if</span> <span class="n">compat</span><span class="o">.</span><span class="n">in_py2</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pkgutil</span> <span class="k">import</span> <span class="n">find_loader</span> <span class="k">as</span> <span class="n">have_package</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">importlib.util</span> <span class="k">import</span> <span class="n">find_spec</span> <span class="k">as</span> <span class="n">have_package</span>

<span class="n">have_numpy</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">numpy</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">have_numpy</span> <span class="o">=</span> <span class="kc">False</span>


<div class="viewcode-block" id="PropertyError"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.PropertyError">[docs]</a><span class="k">class</span> <span class="nc">PropertyError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;For AttributeErrors caught in a property, so do not go to __getattr__&quot;&quot;&quot;</span>
    <span class="c1">#  http://docs.python.org/release/3.1.3/tutorial/errors.html#tut-userexceptions</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="PrivateBlock"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.PrivateBlock">[docs]</a><span class="k">class</span> <span class="nc">PrivateBlock</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper class for a private block in the dataset.</span>
<span class="sd">    (See PS3.5, Section 7.8.1 - Private Data Element Tags)</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    group : 32 bit int</span>
<span class="sd">        The private group where the private block is located.</span>
<span class="sd">    private_creator : str</span>
<span class="sd">        The private creator string related to the block.</span>
<span class="sd">    dataset : Dataset</span>
<span class="sd">        The parent dataset.</span>
<span class="sd">    block_start : 32 bit int</span>
<span class="sd">        The start element of the private block.</span>
<span class="sd">        Note that the 2 low order hex digits of the element are always 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">private_creator_element</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initializes an object corresponding to a private tag block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : tuple (int, str)</span>
<span class="sd">            The private group and private creator. The group must be an odd</span>
<span class="sd">            number.</span>
<span class="sd">        dataset : Dataset</span>
<span class="sd">            The parent dataset.</span>
<span class="sd">        private_creator_element : 32 bit int</span>
<span class="sd">            The element of the private creator tag.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">private_creator</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_start</span> <span class="o">=</span> <span class="n">private_creator_element</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span>

<div class="viewcode-block" id="PrivateBlock.get_tag"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.PrivateBlock.get_tag">[docs]</a>    <span class="k">def</span> <span class="nf">get_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element_offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the private tag ID for the given element offset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        element_offset : 16 bit int</span>
<span class="sd">            The lower 16 bit (e.g. 2 hex numbers) of the element tag.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            The tag ID defined by the private block location and the</span>
<span class="sd">            given element offset.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `element_offset` is too large.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">element_offset</span> <span class="o">&gt;</span> <span class="mh">0xff</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Element offset must be less than 256&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Tag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_start</span> <span class="o">+</span> <span class="n">element_offset</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element_offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the tag with given element offset is contained in</span>
<span class="sd">        the parent dataset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tag</span><span class="p">(</span><span class="n">element_offset</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element_offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the data element in the parent dataset for the given element</span>
<span class="sd">        offset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        element_offset : 16 bit int</span>
<span class="sd">            The lower 16 bit (e.g. 2 hex numbers) of the element tag.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            The data element of the tag in the parent dataset defined by the</span>
<span class="sd">            private block location and the given element offset.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `element_offset` is too large.</span>
<span class="sd">        KeyError</span>
<span class="sd">            If no data element exists at that offset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_tag</span><span class="p">(</span><span class="n">element_offset</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element_offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete the tag with the given element offset from the dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        element_offset : 16 bit int</span>
<span class="sd">            The lower 16 bit (e.g. 2 hex numbers) of the element tag</span>
<span class="sd">            to be deleted.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `element_offset` is too large.</span>
<span class="sd">        KeyError</span>
<span class="sd">            If no data element exists at that offset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_tag</span><span class="p">(</span><span class="n">element_offset</span><span class="p">)]</span>

<div class="viewcode-block" id="PrivateBlock.add_new"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.PrivateBlock.add_new">[docs]</a>    <span class="k">def</span> <span class="nf">add_new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element_offset</span><span class="p">,</span> <span class="n">VR</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the private tag with the given VR and value to the</span>
<span class="sd">         parent dataset at the tag ID defined by the private block</span>
<span class="sd">         and the given element offset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        element_offset : 16 bit int</span>
<span class="sd">            The lower 16 bit (e.g. 2 hex numbers) of the element tag</span>
<span class="sd">            to be added.</span>
<span class="sd">        VR : str</span>
<span class="sd">            The 2 character DICOM value representation.</span>
<span class="sd">        value</span>
<span class="sd">            The value of the data element.</span>
<span class="sd">            See `pydicom.Dataset.add_new` for a description.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">add_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_tag</span><span class="p">(</span><span class="n">element_offset</span><span class="p">),</span> <span class="n">VR</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div></div>



<span class="k">def</span> <span class="nf">_dict_equal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Common method for Dataset.__eq__ and FileDataset.__eq__</span>

<span class="sd">    Uses .keys() as needed because Dataset iter return items not keys</span>
<span class="sd">    `exclude` is used in FileDataset__eq__ ds.__dict__ compare, which</span>
<span class="sd">    would also compare the wrapped _dict member (entire dataset) again.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="ow">and</span>
            <span class="nb">all</span><span class="p">(</span><span class="n">key</span> <span class="ow">in</span> <span class="n">b</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span>
            <span class="nb">all</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">)</span>
            <span class="p">)</span>


<div class="viewcode-block" id="Dataset"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset">[docs]</a><span class="k">class</span> <span class="nc">Dataset</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Contains a collection (dictionary) of DICOM DataElements.</span>
<span class="sd">    Behaves like a dictionary.</span>

<span class="sd">    .. note::</span>

<span class="sd">        `Dataset` is derived from `dict` only to make it work in a NumPy</span>
<span class="sd">        array. The parent dict class is never called, as all `dict` methods</span>
<span class="sd">        are overridden.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Add DataElements to the Dataset (for elements in the DICOM dictionary):</span>

<span class="sd">    &gt;&gt;&gt; ds = Dataset()</span>
<span class="sd">    &gt;&gt;&gt; ds.PatientName = &quot;CITIZEN^Joan&quot;</span>
<span class="sd">    &gt;&gt;&gt; ds.add_new(0x00100020, &#39;LO&#39;, &#39;12345&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ds[0x0010, 0x0030] = DataElement(0x00100030, &#39;DA&#39;, &#39;20010101&#39;)</span>

<span class="sd">    Add Sequence DataElement to the Dataset:</span>

<span class="sd">    &gt;&gt;&gt; ds.BeamSequence = [Dataset(), Dataset(), Dataset()]</span>
<span class="sd">    &gt;&gt;&gt; ds.BeamSequence[0].Manufacturer = &quot;Linac, co.&quot;</span>
<span class="sd">    &gt;&gt;&gt; ds.BeamSequence[1].Manufacturer = &quot;Linac and Sons, co.&quot;</span>
<span class="sd">    &gt;&gt;&gt; ds.BeamSequence[2].Manufacturer = &quot;Linac and Daughters, co.&quot;</span>

<span class="sd">    Add private DataElements to the Dataset:</span>

<span class="sd">    &gt;&gt;&gt; block = ds.private_block(0x0041, &#39;My Creator&#39;, create=True)</span>
<span class="sd">    &gt;&gt;&gt; block.add_new(0x01, &#39;LO&#39;, &#39;12345&#39;)</span>

<span class="sd">    Updating and retrieving DataElement values:</span>

<span class="sd">    &gt;&gt;&gt; ds.PatientName = &quot;CITIZEN^Joan&quot;</span>
<span class="sd">    &gt;&gt;&gt; ds.PatientName</span>
<span class="sd">    &#39;CITIZEN^Joan&#39;</span>
<span class="sd">    &gt;&gt;&gt; ds.PatientName = &quot;CITIZEN^John&quot;</span>
<span class="sd">    &gt;&gt;&gt; ds.PatientName</span>
<span class="sd">    &#39;CITIZEN^John&#39;</span>

<span class="sd">    Retrieving a DataElement&#39;s value from a Sequence:</span>

<span class="sd">    &gt;&gt;&gt; ds.BeamSequence[0].Manufacturer</span>
<span class="sd">    &#39;Linac, co.&#39;</span>
<span class="sd">    &gt;&gt;&gt; ds.BeamSequence[1].Manufacturer</span>
<span class="sd">    &#39;Linac and Sons, co.&#39;</span>

<span class="sd">    Retrieving DataElements:</span>

<span class="sd">    &gt;&gt;&gt; elem = ds[0x00100010]</span>
<span class="sd">    &gt;&gt;&gt; elem</span>
<span class="sd">    (0010, 0010) Patient&#39;s Name                      PN: &#39;CITIZEN^John&#39;</span>
<span class="sd">    &gt;&gt;&gt; elem = ds.data_element(&#39;PatientName&#39;)</span>
<span class="sd">    &gt;&gt;&gt; elem</span>
<span class="sd">    (0010, 0010) Patient&#39;s Name                      PN: &#39;CITIZEN^John&#39;</span>

<span class="sd">    Retrieving a private DataElement:</span>

<span class="sd">    &gt;&gt;&gt; block = ds.private_block(0x0041, &#39;My Creator&#39;)</span>
<span class="sd">    &gt;&gt;&gt; elem = block[0x01]</span>
<span class="sd">    &gt;&gt;&gt; elem</span>
<span class="sd">    (0041, 1001) Private tag data                    LO: &#39;12345&#39;</span>

<span class="sd">    &gt;&gt;&gt; elem.value</span>
<span class="sd">    &#39;12345&#39;</span>

<span class="sd">    Alternatively:</span>
<span class="sd">    &gt;&gt;&gt; ds.get_private_item(0x0041, 0x01, &#39;My Creator&#39;).value</span>
<span class="sd">    &#39;12345&#39;</span>

<span class="sd">    Deleting a DataElement from the Dataset:</span>

<span class="sd">    &gt;&gt;&gt; del ds.PatientID</span>
<span class="sd">    &gt;&gt;&gt; del ds.BeamSequence[1].Manufacturer</span>
<span class="sd">    &gt;&gt;&gt; del ds.BeamSequence[2]</span>

<span class="sd">    Deleting a private DataElement from the Dataset:</span>

<span class="sd">    &gt;&gt;&gt; block = ds.private_block(0x0041, &#39;My Creator&#39;)</span>
<span class="sd">    &gt;&gt;&gt; if 0x01 in block:</span>
<span class="sd">    ...     del block[0x01]</span>

<span class="sd">    Determining if a DataElement is present in the Dataset:</span>

<span class="sd">    &gt;&gt;&gt; &#39;PatientName&#39; in ds</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; &#39;PatientID&#39; in ds</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; (0x0010, 0x0030) in ds</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; &#39;Manufacturer&#39; in ds.BeamSequence[0]</span>
<span class="sd">    True</span>

<span class="sd">    Iterating through the top level of a Dataset only (excluding Sequences):</span>

<span class="sd">    &gt;&gt;&gt; for elem in ds:</span>
<span class="sd">    ...    print(elem)   #doctest: +ELLIPSIS</span>
<span class="sd">    (0010, 0010) Patient&#39;s Name                      PN: &#39;CITIZEN^John&#39;...</span>

<span class="sd">    Iterating through the entire Dataset (including Sequences):</span>

<span class="sd">    &gt;&gt;&gt; for elem in ds.iterall():</span>
<span class="sd">    ...     print(elem)  #doctest: +ELLIPSIS</span>
<span class="sd">    (0010, 0010) Patient&#39;s Name                      PN: &#39;CITIZEN^John&#39;...</span>

<span class="sd">    Recursively iterate through a Dataset (including Sequences):</span>

<span class="sd">    &gt;&gt;&gt; def recurse(ds):</span>
<span class="sd">    ...     for elem in ds:</span>
<span class="sd">    ...         if elem.VR == &#39;SQ&#39;:</span>
<span class="sd">    ...             [recurse(item) for item in elem]</span>
<span class="sd">    ...         else:</span>
<span class="sd">    ...             # Do something useful with each DataElement</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    default_element_format : str</span>
<span class="sd">        The default formatting for string display.</span>
<span class="sd">    default_sequence_element_format : str</span>
<span class="sd">        The default formatting for string display of sequences.</span>
<span class="sd">    indent_chars : str</span>
<span class="sd">        For string display, the characters used to indent nested Sequences.</span>
<span class="sd">        Default is &quot;   &quot;.</span>
<span class="sd">    is_little_endian : bool</span>
<span class="sd">        Shall be set before writing with `write_like_original=False`.</span>
<span class="sd">        The written dataset (excluding the pixel data) will be written using</span>
<span class="sd">        the given endianess.</span>
<span class="sd">    is_implicit_VR : bool</span>
<span class="sd">        Shall be set before writing with `write_like_original=False`.</span>
<span class="sd">        The written dataset will be written using the transfer syntax with</span>
<span class="sd">        the given VR handling, e.g LittleEndianImplicit if True,</span>
<span class="sd">        and LittleEndianExplicit or BigEndianExplicit (depending on</span>
<span class="sd">        `is_little_endian`) if False.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">indent_chars</span> <span class="o">=</span> <span class="s2">&quot;   &quot;</span>

    <span class="c1"># Python 2: Classes defining __eq__ should flag themselves as unhashable</span>
    <span class="fm">__hash__</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new Dataset instance.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent_encoding</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;parent_encoding&#39;</span><span class="p">,</span> <span class="n">default_encoding</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_dict</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_decompressed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># the following read_XXX attributes are used internally to store</span>
        <span class="c1"># the properties of the dataset after read from a file</span>

        <span class="c1"># set depending on the endianess of the read dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_little_endian</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># set depending on the VR handling of the read dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_implicit_vr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># set to the encoding the dataset had originally</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_encoding</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">is_little_endian</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_implicit_VR</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># the parent data set, if this dataset is a sequence item</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># known private creator blocks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_private_blocks</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method invoked on entry to a with statement.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method invoked on exit from a with statement.&quot;&quot;&quot;</span>
        <span class="c1"># Returning False will re-raise any exceptions that occur</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="Dataset.add"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_element</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a DataElement to the Dataset.</span>

<span class="sd">        Equivalent to ds[data_element.tag] = data_element</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_element : pydicom.dataelem.DataElement</span>
<span class="sd">            The DataElement to add to the Dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">data_element</span><span class="o">.</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_element</span></div>

<div class="viewcode-block" id="Dataset.add_new"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.add_new">[docs]</a>    <span class="k">def</span> <span class="nf">add_new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">VR</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a DataElement to the Dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tag</span>
<span class="sd">            The DICOM (group, element) tag in any form accepted by</span>
<span class="sd">            pydicom.tag.Tag such as [0x0010, 0x0010], (0x10, 0x10), 0x00100010,</span>
<span class="sd">            etc.</span>
<span class="sd">        VR : str</span>
<span class="sd">            The 2 character DICOM value representation (see DICOM standard part</span>
<span class="sd">            5, Section 6.2).</span>
<span class="sd">        value</span>
<span class="sd">            The value of the data element. One of the following:</span>
<span class="sd">            * a single string or number</span>
<span class="sd">            * a list or tuple with all strings or all numbers</span>
<span class="sd">            * a multi-value string with backslash separator</span>
<span class="sd">            * for a sequence DataElement, an empty list or list of Dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data_element</span> <span class="o">=</span> <span class="n">DataElement</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">VR</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="c1"># use data_element.tag since DataElement verified it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="p">[</span><span class="n">data_element</span><span class="o">.</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_element</span></div>

<div class="viewcode-block" id="Dataset.data_element"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.data_element">[docs]</a>    <span class="k">def</span> <span class="nf">data_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the DataElement corresponding to the element keyword `name`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            A DICOM element keyword.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pydicom.dataelem.DataElement or None</span>
<span class="sd">            For the given DICOM element `keyword`, return the corresponding</span>
<span class="sd">            Dataset DataElement if present, None otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">tag_for_keyword</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># Test against None as (0000,0000) is a possible tag</span>
        <span class="k">if</span> <span class="n">tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Simulate dict.__contains__() to handle DICOM keywords.</span>

<span class="sd">        This is called for code like:</span>
<span class="sd">        &gt;&gt;&gt; ds = Dataset()</span>
<span class="sd">        &gt;&gt;&gt; ds.SliceLocation = &#39;2&#39;</span>
<span class="sd">        &gt;&gt;&gt; &#39;SliceLocation&#39; in ds</span>
<span class="sd">        True</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str or int or 2-tuple</span>
<span class="sd">            The Element keyword or tag to search for.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if the DataElement is in the Dataset, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="n">Tag</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># Test against None as (0000,0000) is a possible tag</span>
        <span class="k">if</span> <span class="n">tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span>
        <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span>  <span class="c1"># will no doubt raise an exception</span>

<div class="viewcode-block" id="Dataset.decode"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.decode">[docs]</a>    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply character set decoding to all DataElements in the Dataset.</span>

<span class="sd">        See DICOM PS3.5-2008 6.1.1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find specific character set. &#39;ISO_IR 6&#39; is default</span>
        <span class="c1"># May be multi-valued, but let pydicom.charset handle all logic on that</span>
        <span class="n">dicom_character_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_character_set</span>

        <span class="c1"># Shortcut to the decode function in pydicom.charset</span>
        <span class="n">decode_data_element</span> <span class="o">=</span> <span class="n">pydicom</span><span class="o">.</span><span class="n">charset</span><span class="o">.</span><span class="n">decode</span>

        <span class="c1"># Callback for walk(), to decode the chr strings if necessary</span>
        <span class="c1"># This simply calls the pydicom.charset.decode function</span>
        <span class="k">def</span> <span class="nf">decode_callback</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">data_element</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Callback to decode `data_element`.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">data_element</span><span class="o">.</span><span class="n">VR</span> <span class="o">==</span> <span class="s1">&#39;SQ&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">dset</span> <span class="ow">in</span> <span class="n">data_element</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                    <span class="n">dset</span><span class="o">.</span><span class="n">_parent_encoding</span> <span class="o">=</span> <span class="n">dicom_character_set</span>
                    <span class="n">dset</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">decode_data_element</span><span class="p">(</span><span class="n">data_element</span><span class="p">,</span> <span class="n">dicom_character_set</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">decode_callback</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Intercept requests to delete an attribute by `name`.</span>

<span class="sd">        &gt;&gt;&gt; ds = Dataset()</span>
<span class="sd">        &gt;&gt;&gt; ds.PatientName = &#39;foo&#39;</span>
<span class="sd">        &gt;&gt;&gt; ds.some_attribute = True</span>

<span class="sd">        If `name` is a DICOM keyword - delete the corresponding DataElement</span>
<span class="sd">        &gt;&gt;&gt; del ds.PatientName</span>
<span class="sd">        &gt;&gt;&gt; &#39;PatientName&#39; in ds</span>
<span class="sd">        False</span>

<span class="sd">        If `name` is another attribute - delete it</span>
<span class="sd">        &gt;&gt;&gt; del ds.some_attribute</span>
<span class="sd">        &gt;&gt;&gt; hasattr(ds, &#39;some_attribute&#39;)</span>
<span class="sd">        False</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            The keyword for the DICOM element or the class attribute to delete.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First check if a valid DICOM keyword and if we have that data element</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">tag_for_keyword</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
        <span class="c1"># If not a DICOM name in this dataset, check for regular instance name</span>
        <span class="c1">#   can&#39;t do delete directly, that will call __delattr__ again</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="c1"># Not found, raise an error in same style as python does</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Intercept requests to delete an attribute by key.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Indexing using DataElement tag</span>
<span class="sd">        &gt;&gt;&gt; ds = Dataset()</span>
<span class="sd">        &gt;&gt;&gt; ds.CommandGroupLength = 100</span>
<span class="sd">        &gt;&gt;&gt; ds.PatientName = &#39;CITIZEN^Jan&#39;</span>
<span class="sd">        &gt;&gt;&gt; del ds[0x00000000]</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        (0010, 0010) Patient&#39;s Name                      PN: &#39;CITIZEN^Jan&#39;</span>

<span class="sd">        Slicing using DataElement tag</span>
<span class="sd">        &gt;&gt;&gt; ds = Dataset()</span>
<span class="sd">        &gt;&gt;&gt; ds.CommandGroupLength = 100</span>
<span class="sd">        &gt;&gt;&gt; ds.SOPInstanceUID = &#39;1.2.3&#39;</span>
<span class="sd">        &gt;&gt;&gt; ds.PatientName = &#39;CITIZEN^Jan&#39;</span>
<span class="sd">        &gt;&gt;&gt; del ds[:0x00100000]</span>
<span class="sd">        &gt;&gt;&gt; ds</span>
<span class="sd">        (0010, 0010) Patient&#39;s Name                      PN: &#39;CITIZEN^Jan&#39;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key</span>
<span class="sd">            The key for the attribute to be deleted. If a slice is used then</span>
<span class="sd">            the tags matching the slice conditions will be deleted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If passed a slice, delete the corresponding DataElements</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice_dataset</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">):</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume is a standard tag (for speed in common case)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="c1"># If not a standard tag, than convert to Tag and try again</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="n">Tag</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Give a list of attributes available in the Dataset.</span>

<span class="sd">        List of attributes is used, for example, in auto-completion in editors</span>
<span class="sd">        or command-line environments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Force zip object into a list in case of python3. Also backwards</span>
        <span class="c1"># compatible</span>
        <span class="n">meths</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
            <span class="o">*</span><span class="n">inspect</span><span class="o">.</span><span class="n">getmembers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isroutine</span><span class="p">)))[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">props</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
            <span class="o">*</span><span class="n">inspect</span><span class="o">.</span><span class="n">getmembers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isdatadescriptor</span><span class="p">)))[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">dicom_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dir</span><span class="p">())</span>
        <span class="n">alldir</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">props</span> <span class="o">|</span> <span class="n">meths</span> <span class="o">|</span> <span class="n">dicom_names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">alldir</span>

<div class="viewcode-block" id="Dataset.dir"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.dir">[docs]</a>    <span class="k">def</span> <span class="nf">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">filters</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an alphabetical list of DataElement keywords in the Dataset.</span>

<span class="sd">        Intended mainly for use in interactive Python sessions. Only lists the</span>
<span class="sd">        DataElement keywords in the current level of the Dataset (i.e. the</span>
<span class="sd">        contents of any Sequence elements are ignored).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filters : str</span>
<span class="sd">            Zero or more string arguments to the function. Used for</span>
<span class="sd">            case-insensitive match to any part of the DICOM keyword.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of str</span>
<span class="sd">            The matching DataElement keywords in the dataset. If no filters are</span>
<span class="sd">            used then all DataElement keywords are returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">allnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">keyword_for_tag</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
        <span class="c1"># remove blanks - tags without valid names (e.g. private tags)</span>
        <span class="n">allnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">allnames</span> <span class="k">if</span> <span class="n">x</span><span class="p">]</span>
        <span class="c1"># Store found names in a dict, so duplicate names appear only once</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">filter_</span> <span class="ow">in</span> <span class="n">filters</span><span class="p">:</span>
            <span class="n">filter_</span> <span class="o">=</span> <span class="n">filter_</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="n">match</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">allnames</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">filter_</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">matches</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">match</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">filters</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">matches</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">allnames</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compare `self` and `other` for equality.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            The result if `self` and `other` are the same class</span>
<span class="sd">        NotImplemented</span>
<span class="sd">            If `other` is not the same class as `self` then returning</span>
<span class="sd">            NotImplemented delegates the result to superclass.__eq__(subclass)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># When comparing against self this will be faster</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_dict_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">NotImplemented</span>

<div class="viewcode-block" id="Dataset.get"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Simulate dict.get() to handle DICOM DataElement tags and keywords.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : str or pydicom.tag.Tag</span>
<span class="sd">            The element keyword or Tag or the class attribute name to get.</span>
<span class="sd">        default : obj or None</span>
<span class="sd">            If the DataElement or class attribute is not present, return</span>
<span class="sd">            `default` (default None).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value</span>
<span class="sd">            If `key` is the keyword for a DataElement in the Dataset then</span>
<span class="sd">            return the DataElement&#39;s value.</span>
<span class="sd">        pydicom.dataelem.DataElement</span>
<span class="sd">            If `key` is a tag for a DataElement in the Dataset then return the</span>
<span class="sd">            DataElement instance.</span>
<span class="sd">        value</span>
<span class="sd">            If `key` is a class attribute then return its value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">compat</span><span class="o">.</span><span class="n">text_type</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">default</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># is not a string, try to make it into a tag and then hand it</span>
            <span class="c1"># off to the underlying dict</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">BaseTag</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="n">Tag</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Dataset.get key must be a string or tag&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span></div>

<div class="viewcode-block" id="Dataset.items"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.items">[docs]</a>    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the elements in the Dataset as a list of tuple.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of tuple</span>
<span class="sd">            The top-level (element tag, element) for the Dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span></div>

<div class="viewcode-block" id="Dataset.keys"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.keys">[docs]</a>    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the DICOM tag keys to simulate dict.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span></div>

<div class="viewcode-block" id="Dataset.values"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.values">[docs]</a>    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the DICOM tag values to simulate dict.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span></div>

    <span class="k">if</span> <span class="n">compat</span><span class="o">.</span><span class="n">in_py2</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">iterkeys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">itervalues</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Intercept requests for Dataset attribute names.</span>

<span class="sd">        If `name` matches a DICOM keyword, return the value for the</span>
<span class="sd">        DataElement with the corresponding tag.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name</span>
<span class="sd">            A DataElement keyword or tag or a class attribute name.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value</span>
<span class="sd">              If `name` matches a DICOM keyword, returns the corresponding</span>
<span class="sd">              DataElement&#39;s value. Otherwise returns the class attribute&#39;s</span>
<span class="sd">              value (if present).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">tag_for_keyword</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># `name` isn&#39;t a DICOM element keyword</span>
            <span class="c1"># Try the base class attribute getter (fix for issue 332)</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">Tag</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="p">:</span>  <span class="c1"># DICOM DataElement not in the Dataset</span>
            <span class="c1"># Try the base class attribute getter (fix for issue 332)</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_elem</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">data_elem</span><span class="o">.</span><span class="n">value</span>
            <span class="k">if</span> <span class="n">data_elem</span><span class="o">.</span><span class="n">VR</span> <span class="o">==</span> <span class="s1">&#39;SQ&#39;</span><span class="p">:</span>
                <span class="c1"># let a sequence know its parent dataset, as sequence items</span>
                <span class="c1"># may need parent dataset tags to resolve ambiguous tags</span>
                <span class="n">value</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">return</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_character_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The Dataset&#39;s SpecificCharacterSet value (if present).&quot;&quot;&quot;</span>
        <span class="n">char_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">BaseTag</span><span class="p">(</span><span class="mh">0x00080005</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">char_set</span><span class="p">:</span>
            <span class="n">char_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_encoding</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">char_set</span> <span class="o">=</span> <span class="n">convert_encodings</span><span class="p">(</span><span class="n">char_set</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">char_set</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Operator for Dataset[key] request.</span>

<span class="sd">        Any deferred data elements will be read in and an attempt will be made</span>
<span class="sd">        to correct any elements with ambiguous VRs.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Indexing using DataElement tag</span>
<span class="sd">        &gt;&gt;&gt; ds = Dataset()</span>
<span class="sd">        &gt;&gt;&gt; ds.SOPInstanceUID = &#39;1.2.3&#39;</span>
<span class="sd">        &gt;&gt;&gt; ds.PatientName = &#39;CITIZEN^Jan&#39;</span>
<span class="sd">        &gt;&gt;&gt; ds.PatientID = &#39;12345&#39;</span>
<span class="sd">        &gt;&gt;&gt; ds[0x00100010].value</span>
<span class="sd">        &#39;CITIZEN^Jan&#39;</span>

<span class="sd">        Slicing using DataElement tag</span>
<span class="sd">        All group 0x0010 elements in the dataset</span>
<span class="sd">        &gt;&gt;&gt; ds[0x00100000:0x00110000]</span>
<span class="sd">        (0010, 0010) Patient&#39;s Name                      PN: &#39;CITIZEN^Jan&#39;</span>
<span class="sd">        (0010, 0020) Patient ID                          LO: &#39;12345&#39;</span>

<span class="sd">        All group 0x0002 elements in the dataset</span>
<span class="sd">        &gt;&gt;&gt; ds[(0x0002, 0x0000):(0x0003, 0x0000)]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key</span>
<span class="sd">            The DICOM (group, element) tag in any form accepted by</span>
<span class="sd">            pydicom.tag.Tag such as [0x0010, 0x0010], (0x10, 0x10), 0x00100010,</span>
<span class="sd">            etc. May also be a slice made up of DICOM tags.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pydicom.dataelem.DataElement or pydicom.dataset.Dataset</span>
<span class="sd">            If a single DICOM element tag is used then returns the</span>
<span class="sd">            corresponding DataElement. If a slice is used then returns a</span>
<span class="sd">            Dataset object containing the corresponding DataElements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If passed a slice, return a Dataset containing the corresponding</span>
        <span class="c1">#   DataElements</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_slice</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">BaseTag</span><span class="p">):</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="n">Tag</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">data_elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_elem</span><span class="p">,</span> <span class="n">DataElement</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">data_elem</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_elem</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="c1"># If a deferred read, then go get the value now</span>
            <span class="k">if</span> <span class="n">data_elem</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">pydicom.filereader</span> <span class="k">import</span> <span class="n">read_deferred_data_element</span>
                <span class="n">data_elem</span> <span class="o">=</span> <span class="n">read_deferred_data_element</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fileobj_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span>
                    <span class="n">data_elem</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">tag</span> <span class="o">!=</span> <span class="n">BaseTag</span><span class="p">(</span><span class="mh">0x00080005</span><span class="p">):</span>
                <span class="n">character_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_encoding</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_character_set</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">character_set</span> <span class="o">=</span> <span class="n">default_encoding</span>
            <span class="c1"># Not converted from raw form read from file yet; do so now</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">DataElement_from_raw</span><span class="p">(</span><span class="n">data_elem</span><span class="p">,</span> <span class="n">character_set</span><span class="p">)</span>

            <span class="c1"># If the Element has an ambiguous VR, try to correct it</span>
            <span class="k">if</span> <span class="s1">&#39;or&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span><span class="o">.</span><span class="n">VR</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">pydicom.filewriter</span> <span class="k">import</span> <span class="n">correct_ambiguous_vr_element</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">correct_ambiguous_vr_element</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">tag</span><span class="p">],</span> <span class="bp">self</span><span class="p">,</span> <span class="n">data_elem</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>

<div class="viewcode-block" id="Dataset.private_block"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.private_block">[docs]</a>    <span class="k">def</span> <span class="nf">private_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">private_creator</span><span class="p">,</span> <span class="n">create</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the block for the given tag and private creator.</span>

<span class="sd">        If `create` is set and the private creator does not exist,</span>
<span class="sd">        the private creator tag is added.</span>
<span class="sd">        Note: We ignore the unrealistic case that no free block is</span>
<span class="sd">        available.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        group : 32 bit int</span>
<span class="sd">            The group of the private tag to be found. Must be an odd number</span>
<span class="sd">            (e.g. a private group).</span>
<span class="sd">        private_creator : str</span>
<span class="sd">            The private creator string associated with the tag.</span>
<span class="sd">        create : bool</span>
<span class="sd">            If `True` and `private_creator` does not exist, a new private</span>
<span class="sd">            creator tag is added at the next free block.</span>
<span class="sd">            If `False` (the default) and `private_creator` does not exist,</span>
<span class="sd">            `KeyError` is raised instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        32 bit int</span>
<span class="sd">            Element base for the given tag (the last 2 hex digits are always 0)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `tag` is not a private tag or `private_creator` is empty.</span>
<span class="sd">        KeyError</span>
<span class="sd">            If the private creator tag is not found in the given group and</span>
<span class="sd">            the `create` parameter is not set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">new_block</span><span class="p">():</span>
            <span class="n">block</span> <span class="o">=</span> <span class="n">PrivateBlock</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_private_blocks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span>
            <span class="k">return</span> <span class="n">block</span>

        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">private_creator</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_private_blocks</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_private_blocks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">private_creator</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Private creator must have a value&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">group</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Tag must be private if private creator is given&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">):</span>
            <span class="n">private_creator_tag</span> <span class="o">=</span> <span class="n">Tag</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">private_creator_tag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">create</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_new</span><span class="p">(</span><span class="n">private_creator_tag</span><span class="p">,</span> <span class="s1">&#39;LO&#39;</span><span class="p">,</span> <span class="n">private_creator</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">new_block</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="p">[</span><span class="n">private_creator_tag</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">private_creator</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">new_block</span><span class="p">()</span>

        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
            <span class="s2">&quot;Private creator &#39;</span><span class="si">{}</span><span class="s2">&#39; not found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">private_creator</span><span class="p">))</span></div>

<div class="viewcode-block" id="Dataset.private_creators"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.private_creators">[docs]</a>    <span class="k">def</span> <span class="nf">private_creators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of private creator names in the given group.</span>

<span class="sd">        This can be used to check if a given private creator exists in</span>
<span class="sd">        the group of the dataset:</span>
<span class="sd">        &gt;&gt;&gt; ds = Dataset()</span>
<span class="sd">        &gt;&gt;&gt; if &#39;My Creator&#39; in ds.private_creators(0x0041):</span>
<span class="sd">        ...     block = ds.private_block(0x0041, &#39;My Creator&#39;)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        group : 32 bit int</span>
<span class="sd">            The private group. Must be an odd number.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of str</span>
<span class="sd">            List of all private creator names for private blocks in the group.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `group` is not a private group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">group</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Group must be an odd number&#39;</span><span class="p">)</span>

        <span class="n">private_creators</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">):</span>
            <span class="n">private_creator_tag</span> <span class="o">=</span> <span class="n">Tag</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">private_creator_tag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">private_creators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="p">[</span><span class="n">private_creator_tag</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">private_creators</span></div>

<div class="viewcode-block" id="Dataset.get_private_item"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.get_private_item">[docs]</a>    <span class="k">def</span> <span class="nf">get_private_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">element_offset</span><span class="p">,</span> <span class="n">private_creator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the data element for the given private tag.</span>

<span class="sd">        This is analogous to `__getitem__`, but only for private tags.</span>
<span class="sd">        This allows to find the private tag for the correct private creator</span>
<span class="sd">        without the need to add the tag to the private dictionary first.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        group : 32 bit int</span>
<span class="sd">            The private group where the item is located.</span>
<span class="sd">        element_offset : 16 bit int</span>
<span class="sd">            The lower 16 bit (e.g. 2 hex numbers) of the element tag.</span>
<span class="sd">        private_creator : str</span>
<span class="sd">            The private creator for the tag. Must match the private creator</span>
<span class="sd">            for the tag to be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pydicom.dataelem.DataElement</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `tag` is not a private tag or `private_creator` is empty.</span>
<span class="sd">        KeyError</span>
<span class="sd">            If the private creator tag is not found in the given group.</span>
<span class="sd">            If the private tag is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">private_block</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">private_creator</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">get_tag</span><span class="p">(</span><span class="n">element_offset</span><span class="p">))</span></div>

<div class="viewcode-block" id="Dataset.get_item"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.get_item">[docs]</a>    <span class="k">def</span> <span class="nf">get_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the raw data element if possible.</span>

<span class="sd">        It will be raw if the user has never accessed the value, or set their</span>
<span class="sd">        own value. Note if the data element is a deferred-read element,</span>
<span class="sd">        then it is read and converted before being returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key</span>
<span class="sd">            The DICOM (group, element) tag in any form accepted by</span>
<span class="sd">            pydicom.tag.Tag such as [0x0010, 0x0010], (0x10, 0x10), 0x00100010,</span>
<span class="sd">            etc. May also be a slice made up of DICOM tags.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pydicom.dataelem.DataElement</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_slice</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">BaseTag</span><span class="p">):</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="n">Tag</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">data_elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
        <span class="c1"># If a deferred read, return using __getitem__ to read and convert it</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_elem</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data_elem</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">data_elem</span></div>

    <span class="k">def</span> <span class="nf">_dataset_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a slice that has the same properties as the original</span>
<span class="sd">        dataset. That includes properties related to endianess and VR handling,</span>
<span class="sd">        and the specific character set. No element conversion is done, e.g.</span>
<span class="sd">        elements of type RawDataElement are kept.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice_dataset</span><span class="p">(</span><span class="nb">slice</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="nb">slice</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="nb">slice</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">({</span><span class="n">tag</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_item</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">tags</span><span class="p">})</span>
        <span class="n">dataset</span><span class="o">.</span><span class="n">is_little_endian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_little_endian</span>
        <span class="n">dataset</span><span class="o">.</span><span class="n">is_implicit_VR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_implicit_VR</span>
        <span class="n">dataset</span><span class="o">.</span><span class="n">set_original_encoding</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">read_implicit_vr</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">read_little_endian</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">read_encoding</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dataset</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_original_encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the properties to be used for writing are set and</span>
<span class="sd">        have the same value as the ones in the dataset after reading it.</span>
<span class="sd">        This includes properties related to endianess, VR handling and the</span>
<span class="sd">        specific character set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_implicit_VR</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">is_little_endian</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">read_implicit_vr</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_implicit_VR</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">read_little_endian</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_little_endian</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">read_encoding</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_character_set</span><span class="p">)</span>

<div class="viewcode-block" id="Dataset.set_original_encoding"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.set_original_encoding">[docs]</a>    <span class="k">def</span> <span class="nf">set_original_encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_implicit_vr</span><span class="p">,</span> <span class="n">is_little_endian</span><span class="p">,</span>
                              <span class="n">character_encoding</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the values for the original transfer syntax and encoding.</span>
<span class="sd">        Can be used for a dataset with raw data elements to enable</span>
<span class="sd">        optimized writing (e.g. without decoding the data elements).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_implicit_vr</span> <span class="o">=</span> <span class="n">is_implicit_vr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_little_endian</span> <span class="o">=</span> <span class="n">is_little_endian</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_encoding</span> <span class="o">=</span> <span class="n">character_encoding</span></div>

<div class="viewcode-block" id="Dataset.group_dataset"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.group_dataset">[docs]</a>    <span class="k">def</span> <span class="nf">group_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a Dataset containing only DataElements of a certain group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        group : int</span>
<span class="sd">            The group part of a DICOM (group, element) tag.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pydicom.dataset.Dataset</span>
<span class="sd">            A dataset instance containing elements of the group specified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[(</span><span class="n">group</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">):(</span><span class="n">group</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">)]</span></div>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate through the top-level of the Dataset, yielding DataElements.</span>

<span class="sd">        &gt;&gt;&gt; ds = Dataset()</span>
<span class="sd">        &gt;&gt;&gt; for elem in ds:</span>
<span class="sd">        ...     print(elem)</span>

<span class="sd">        The DataElements are returned in increasing tag value order.</span>
<span class="sd">        Sequence items are returned as a single DataElement, so it is up to the</span>
<span class="sd">        calling code to recurse into the Sequence items if desired.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        pydicom.dataelem.DataElement</span>
<span class="sd">            The Dataset&#39;s DataElements, sorted by increasing tag order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note this is different than the underlying dict class,</span>
        <span class="c1">#        which returns the key of the key:value mapping.</span>
        <span class="c1">#   Here the value is returned (but data_element.tag has the key)</span>
        <span class="n">taglist</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">taglist</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>

<div class="viewcode-block" id="Dataset.elements"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.elements">[docs]</a>    <span class="k">def</span> <span class="nf">elements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate through the top-level of the Dataset, yielding DataElements</span>
<span class="sd">        or RawDataElements (no conversion done).</span>

<span class="sd">        &gt;&gt;&gt; ds = Dataset()</span>
<span class="sd">        &gt;&gt;&gt; for elem in ds.elements():</span>
<span class="sd">        ...     print(elem)</span>

<span class="sd">        The elements are returned in the same way as in __getitem__.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        pydicom.dataelem.DataElement or pydicom.dataelem.RawDataElement</span>
<span class="sd">            The Dataset&#39;s DataElements, sorted by increasing tag order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">taglist</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">taglist</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_item</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compare `self` and `other` for inequality.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

<div class="viewcode-block" id="Dataset.clear"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete all data elements.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>

<div class="viewcode-block" id="Dataset.pop"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.pop">[docs]</a>    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Emulate dictionary `pop`, but additionally support tag ID tuple</span>
<span class="sd">        and DICOM keyword.</span>

<span class="sd">        Removes the data element for `key` if it exists and returns it,</span>
<span class="sd">        otherwise returns a default value if given or raises `KeyError`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key: int or str or 2-tuple</span>
<span class="sd">            if tuple - the group and element number of the DICOM tag</span>
<span class="sd">            if int - the combined group/element number</span>
<span class="sd">            if str - the DICOM keyword of the tag</span>

<span class="sd">        *args: zero or one argument</span>
<span class="sd">            defines the behavior if no tag exists for `key`: if given,</span>
<span class="sd">            it defines the return value, if not given, `KeyError` is raised</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The data element for `key` if it exists, or the default value if given.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            If the key is not a valid tag ID or keyword.</span>
<span class="sd">            If the tag does not exist and no default is given.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="n">Tag</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dataset.popitem"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.popitem">[docs]</a>    <span class="k">def</span> <span class="nf">popitem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span></div>

<div class="viewcode-block" id="Dataset.setdefault"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.setdefault">[docs]</a>    <span class="k">def</span> <span class="nf">setdefault</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Emulate dictionary `setdefault`, but additionally support</span>
<span class="sd">        tag ID tuple and DICOM keyword for `key`, and data element value</span>
<span class="sd">        for `default`.</span>

<span class="sd">        .. usage:</span>

<span class="sd">        &gt;&gt;&gt; ds = Dataset()</span>
<span class="sd">        &gt;&gt;&gt; pname = ds.setdefault((0x0010, 0x0010), &quot;Test&quot;)</span>
<span class="sd">        &gt;&gt;&gt; pname</span>
<span class="sd">        (0010, 0010) Patient&#39;s Name                      PN: &#39;Test&#39;</span>
<span class="sd">        &gt;&gt;&gt; pname.value</span>
<span class="sd">        &#39;Test&#39;</span>
<span class="sd">        &gt;&gt;&gt; psex = ds.setdefault(&#39;PatientSex&#39;,</span>
<span class="sd">        ...     DataElement(0x00100040, &#39;CS&#39;, &#39;F&#39;))</span>
<span class="sd">        &gt;&gt;&gt; psex.value</span>
<span class="sd">        &#39;F&#39;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key: int or str or 2-tuple</span>
<span class="sd">            if tuple - the group and element number of the DICOM tag</span>
<span class="sd">            if int - the combined group/element number</span>
<span class="sd">            if str - the DICOM keyword of the tag</span>

<span class="sd">        default: DataElement or value type or None</span>
<span class="sd">            The default value that is inserted and returned if no data</span>
<span class="sd">            element exists for the given key.</span>
<span class="sd">            If it is not of type DataElement, a DataElement is constructed</span>
<span class="sd">            instead for the given tag ID and default as value. This is only</span>
<span class="sd">            possible for known tags (e.g. tags found via the dictionary</span>
<span class="sd">            lookup).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The data element for `key` if it exists, or the default value if</span>
<span class="sd">        it is a DataElement or None, or a DataElement constructed with</span>
<span class="sd">        `default` as value.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            If the key is not a valid tag ID or keyword.</span>
<span class="sd">            If no tag exists for `key`, default is not a DataElement</span>
<span class="sd">            and not None, and key is not a known DICOM tag.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="n">DataElement</span><span class="p">):</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="n">Tag</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="n">vr</span> <span class="o">=</span> <span class="n">datadict</span><span class="o">.</span><span class="n">dictionary_VR</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
                <span class="n">default</span> <span class="o">=</span> <span class="n">DataElement</span><span class="p">(</span><span class="n">Tag</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">vr</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">default</span>
        <span class="k">return</span> <span class="n">default</span></div>

<div class="viewcode-block" id="Dataset.convert_pixel_data"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.convert_pixel_data">[docs]</a>    <span class="k">def</span> <span class="nf">convert_pixel_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the Pixel Data to a numpy array internally.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            Converted pixel data is stored internally in the dataset.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If the pixel data is in a compressed image format, the data is</span>
<span class="sd">        decompressed and any related data elements are changed accordingly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if already have converted to a NumPy array</span>
        <span class="c1"># Also check if self.PixelData has changed. If so, get new NumPy array</span>
        <span class="n">already_have</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_pixel_array&quot;</span><span class="p">):</span>
            <span class="n">already_have</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pixel_id</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PixelData</span><span class="p">):</span>
            <span class="n">already_have</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">already_have</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Find all possible handlers that support the transfer syntax</span>
        <span class="n">transfer_syntax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_meta</span><span class="o">.</span><span class="n">TransferSyntaxUID</span>
        <span class="n">possible_handlers</span> <span class="o">=</span> <span class="p">[</span><span class="n">hh</span> <span class="k">for</span> <span class="n">hh</span> <span class="ow">in</span> <span class="n">pydicom</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">pixel_data_handlers</span>
                             <span class="k">if</span> <span class="n">hh</span><span class="o">.</span><span class="n">supports_transfer_syntax</span><span class="p">(</span><span class="n">transfer_syntax</span><span class="p">)]</span>

        <span class="c1"># No handlers support the transfer syntax</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">possible_handlers</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Unable to decode pixel data with a transfer syntax UID of &quot;</span>
                <span class="s2">&quot;&#39;</span><span class="si">{0}</span><span class="s2">&#39; (</span><span class="si">{1}</span><span class="s2">) as there are no pixel data handlers &quot;</span>
                <span class="s2">&quot;available that support it. Please see the pydicom &quot;</span>
                <span class="s2">&quot;documentation for information on supported transfer syntaxes &quot;</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_meta</span><span class="o">.</span><span class="n">TransferSyntaxUID</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">file_meta</span><span class="o">.</span><span class="n">TransferSyntaxUID</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Handlers that both support the transfer syntax and have their</span>
        <span class="c1">#   dependencies met</span>
        <span class="n">available_handlers</span> <span class="o">=</span> <span class="p">[</span><span class="n">hh</span> <span class="k">for</span> <span class="n">hh</span> <span class="ow">in</span> <span class="n">possible_handlers</span> <span class="k">if</span>
                              <span class="n">hh</span><span class="o">.</span><span class="n">is_available</span><span class="p">()]</span>

        <span class="c1"># There are handlers that support the transfer syntax but none of them</span>
        <span class="c1">#   can be used as missing dependencies</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">available_handlers</span><span class="p">:</span>
            <span class="c1"># For each of the possible handlers we want to find which</span>
            <span class="c1">#   dependencies are missing</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;The following handlers are available to decode the pixel &quot;</span>
                <span class="s2">&quot;data however they are missing required dependencies: &quot;</span>
            <span class="p">)</span>
            <span class="n">pkg_msg</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">hh</span> <span class="ow">in</span> <span class="n">possible_handlers</span><span class="p">:</span>
                <span class="n">hh_deps</span> <span class="o">=</span> <span class="n">hh</span><span class="o">.</span><span class="n">DEPENDENCIES</span>
                <span class="c1"># Missing packages</span>
                <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">dd</span> <span class="k">for</span> <span class="n">dd</span> <span class="ow">in</span> <span class="n">hh_deps</span> <span class="k">if</span> <span class="n">have_package</span><span class="p">(</span><span class="n">dd</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">]</span>
                <span class="c1"># Package names</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">hh_deps</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">missing</span><span class="p">]</span>
                <span class="n">pkg_msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> (req. </span><span class="si">{}</span><span class="s2">)&quot;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hh</span><span class="o">.</span><span class="n">HANDLER_NAME</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>
                <span class="p">)</span>

            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pkg_msg</span><span class="p">))</span>

        <span class="n">last_exception</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">handler</span> <span class="ow">in</span> <span class="n">available_handlers</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Use the handler to get a 1D numpy array of the pixel data</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">handler</span><span class="o">.</span><span class="n">get_pixeldata</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pixel_array</span> <span class="o">=</span> <span class="n">reshape_pixel_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>

                <span class="c1"># Some handler/transfer syntax combinations may need to</span>
                <span class="c1">#   convert the color space from YCbCr to RGB</span>
                <span class="k">if</span> <span class="n">handler</span><span class="o">.</span><span class="n">needs_to_convert_to_RGB</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_pixel_array</span> <span class="o">=</span> <span class="n">convert_color_space</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pixel_array</span><span class="p">,</span>
                                                            <span class="s1">&#39;YBR_FULL&#39;</span><span class="p">,</span>
                                                            <span class="s1">&#39;RGB&#39;</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_pixel_id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PixelData</span><span class="p">)</span>

                <span class="k">return</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;Exception raised by pixel data handler&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="n">exc</span>
                <span class="p">)</span>
                <span class="n">last_exception</span> <span class="o">=</span> <span class="n">exc</span>

        <span class="c1"># The only way to get to this point is if we failed to get the pixel</span>
        <span class="c1">#   array because all suitable handlers raised exceptions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pixel_array</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pixel_id</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Unable to decode the pixel data using the following handlers: </span><span class="si">{}</span><span class="s2">.&quot;</span>
            <span class="s2">&quot;Please see the list of supported Transfer Syntaxes in the &quot;</span>
            <span class="s2">&quot;pydicom documentation for alternative packages that might &quot;</span>
            <span class="s2">&quot;be able to decode the data&quot;</span>
            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">hh</span><span class="p">)</span> <span class="k">for</span> <span class="n">hh</span> <span class="ow">in</span> <span class="n">available_handlers</span><span class="p">]))</span>
        <span class="p">)</span>

        <span class="k">raise</span> <span class="n">last_exception</span></div>

<div class="viewcode-block" id="Dataset.decompress"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.decompress">[docs]</a>    <span class="k">def</span> <span class="nf">decompress</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Decompresses pixel data and modifies the Dataset in-place</span>

<span class="sd">        If not a compressed tranfer syntax, then pixel data is converted</span>
<span class="sd">        to a numpy array internally, but not returned.</span>

<span class="sd">        If compressed pixel data, then is decompressed using an image handler,</span>
<span class="sd">        and internal state is updated appropriately:</span>
<span class="sd">            - TransferSyntax is updated to non-compressed form</span>
<span class="sd">            - is_undefined_length for pixel data is set False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            If the pixel data was originally compressed but file is not</span>
<span class="sd">            ExplicitVR LittleEndian as required by Dicom standard</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convert_pixel_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_decompressed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># May have been undefined length pixel data, but won&#39;t be now</span>
        <span class="k">if</span> <span class="s1">&#39;PixelData&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="mh">0x7fe00010</span><span class="p">]</span><span class="o">.</span><span class="n">is_undefined_length</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Make sure correct Transfer Syntax is set</span>
        <span class="c1"># According to the dicom standard PS3.5 section A.4,</span>
        <span class="c1"># all compressed files must have been explicit VR, little endian</span>
        <span class="c1"># First check if was a compressed file</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;file_meta&#39;</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">file_meta</span><span class="o">.</span><span class="n">TransferSyntaxUID</span><span class="o">.</span><span class="n">is_compressed</span><span class="p">):</span>
            <span class="c1"># Check that current file as read does match expected</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_little_endian</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_implicit_VR</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Current dataset does not match expected ExplicitVR &quot;</span>
                       <span class="s2">&quot;LittleEndian transfer syntax from a compressed &quot;</span>
                       <span class="s2">&quot;transfer syntax&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="c1"># All is as expected, updated the Transfer Syntax</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_meta</span><span class="o">.</span><span class="n">TransferSyntaxUID</span> <span class="o">=</span> <span class="n">ExplicitVRLittleEndian</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pixel_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the Pixel Data as a NumPy array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The Pixel Data (7FE0,0010) as a NumPy ndarray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convert_pixel_data</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pixel_array</span>

    <span class="c1"># Format strings spec&#39;d according to python string formatting options</span>
    <span class="c1">#    See http://docs.python.org/library/stdtypes.html#string-formatting-operations # noqa</span>
    <span class="n">default_element_format</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%(tag)s</span><span class="s2"> </span><span class="si">%(name)-35.35s</span><span class="s2"> </span><span class="si">%(VR)s</span><span class="s2">: </span><span class="si">%(repval)s</span><span class="s2">&quot;</span>
    <span class="n">default_sequence_element_format</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%(tag)s</span><span class="s2"> </span><span class="si">%(name)-35.35s</span><span class="s2"> </span><span class="si">%(VR)s</span><span class="s2">: </span><span class="si">%(repval)s</span><span class="s2">&quot;</span>  <span class="c1"># noqa</span>

<div class="viewcode-block" id="Dataset.formatted_lines"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.formatted_lines">[docs]</a>    <span class="k">def</span> <span class="nf">formatted_lines</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">element_format</span><span class="o">=</span><span class="n">default_element_format</span><span class="p">,</span>
            <span class="n">sequence_element_format</span><span class="o">=</span><span class="n">default_sequence_element_format</span><span class="p">,</span>
            <span class="n">indent_format</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate through the Dataset yielding formatted str for each element.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        element_format : str</span>
<span class="sd">            The string format to use for non-sequence elements. Formatting uses</span>
<span class="sd">            the attributes of DataElement. Default is</span>
<span class="sd">            &quot;%(tag)s %(name)-35.35s %(VR)s: %(repval)s&quot;.</span>
<span class="sd">        sequence_element_format : str</span>
<span class="sd">            The string format to use for sequence elements. Formatting uses</span>
<span class="sd">            the attributes of DataElement. Default is</span>
<span class="sd">            &quot;%(tag)s %(name)-35.35s %(VR)s: %(repval)s&quot;</span>
<span class="sd">        indent_format : str or None</span>
<span class="sd">            Placeholder for future functionality.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        str</span>
<span class="sd">            A string representation of a DataElement.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">data_element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterall</span><span class="p">():</span>
            <span class="c1"># Get all the attributes possible for this data element (e.g.</span>
            <span class="c1">#   gets descriptive text name too)</span>
            <span class="c1"># This is the dictionary of names that can be used in the format</span>
            <span class="c1">#   string</span>
            <span class="n">elem_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data_element</span><span class="p">,</span> <span class="n">x</span><span class="p">)()</span>
                               <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">data_element</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="k">else</span>
                               <span class="nb">getattr</span><span class="p">(</span><span class="n">data_element</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
                              <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">data_element</span><span class="p">)</span>
                              <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)])</span>
            <span class="k">if</span> <span class="n">data_element</span><span class="o">.</span><span class="n">VR</span> <span class="o">==</span> <span class="s2">&quot;SQ&quot;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">sequence_element_format</span> <span class="o">%</span> <span class="n">elem_dict</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">element_format</span> <span class="o">%</span> <span class="n">elem_dict</span></div>

    <span class="k">def</span> <span class="nf">_pretty_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">top_level_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a string of the DataElements in the Dataset, with indented</span>
<span class="sd">        levels.</span>

<span class="sd">        This private method is called by the __str__() method for handling</span>
<span class="sd">        print statements or str(dataset), and the __repr__() method.</span>
<span class="sd">        It is also used by top(), therefore the top_level_only flag.</span>
<span class="sd">        This function recurses, with increasing indentation levels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indent : int</span>
<span class="sd">            The indent level offset (default 0)</span>
<span class="sd">        top_level_only : bool</span>
<span class="sd">            When True, only create a string for the top level elements, i.e.</span>
<span class="sd">            exclude elements within any Sequences (default False).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            A string representation of the Dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">strings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">indent_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indent_chars</span> <span class="o">*</span> <span class="n">indent</span>
        <span class="n">nextindent_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indent_chars</span> <span class="o">*</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">data_element</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">tag_in_exception</span><span class="p">(</span><span class="n">data_element</span><span class="o">.</span><span class="n">tag</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">data_element</span><span class="o">.</span><span class="n">VR</span> <span class="o">==</span> <span class="s2">&quot;SQ&quot;</span><span class="p">:</span>  <span class="c1"># a sequence</span>
                    <span class="n">strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indent_str</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">data_element</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span> <span class="o">+</span>
                                   <span class="s2">&quot;  </span><span class="si">%s</span><span class="s2">   </span><span class="si">%i</span><span class="s2"> item(s) ---- &quot;</span> <span class="o">%</span>
                                   <span class="p">(</span><span class="n">data_element</span><span class="o">.</span><span class="n">description</span><span class="p">(),</span>
                                    <span class="nb">len</span><span class="p">(</span><span class="n">data_element</span><span class="o">.</span><span class="n">value</span><span class="p">)))</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">top_level_only</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">data_element</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                            <span class="n">strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">_pretty_str</span><span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                            <span class="n">strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nextindent_str</span> <span class="o">+</span> <span class="s2">&quot;---------&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indent_str</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">data_element</span><span class="p">))</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">strings</span><span class="p">)</span>

<div class="viewcode-block" id="Dataset.remove_private_tags"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.remove_private_tags">[docs]</a>    <span class="k">def</span> <span class="nf">remove_private_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all private DataElements in the Dataset.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">RemoveCallback</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">data_element</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Internal method to use as callback to walk() method.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">data_element</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">is_private</span><span class="p">:</span>
                <span class="c1"># can&#39;t del self[tag] - won&#39;t be right dataset on recursion</span>
                <span class="k">del</span> <span class="n">dataset</span><span class="p">[</span><span class="n">data_element</span><span class="o">.</span><span class="n">tag</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">RemoveCallback</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dataset.save_as"><a class="viewcode-back" href="../../ref_guide.html#pydicom.dataset.Dataset.save_as">[docs]</a>    <span class="k">def</span> <span class="nf">save_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">write_like_original</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the Dataset to `filename`.</span>

<span class="sd">        Saving a Dataset requires that the Dataset.is_implicit_VR and</span>
<span class="sd">        Dataset.is_little_endian attributes exist and are set appropriately. If</span>
<span class="sd">        Dataset.file_meta.TransferSyntaxUID is present then it should be set to</span>
<span class="sd">        a consistent value to ensure conformance.</span>

<span class="sd">        Conformance with DICOM File Format</span>
<span class="sd">        ----------------------------------</span>
<span class="sd">        If `write_like_original` is False, the Dataset will be stored in the</span>
<span class="sd">        DICOM File Format in accordance with DICOM Standard Part 10 Section 7.</span>
<span class="sd">        To do so requires that the `Dataset.file_meta` attribute exists and</span>
<span class="sd">        contains a Dataset with the required (Type 1) File Meta Information</span>
<span class="sd">        Group elements (see pydicom.filewriter.dcmwrite and</span>
<span class="sd">        pydicom.filewriter.write_file_meta_info for more information).</span>

<span class="sd">        If `write_like_original` is True then the Dataset will be written as is</span>
<span class="sd">        (after minimal validation checking) and may or may not contain all or</span>
<span class="sd">        parts of the File Meta Information (and hence may or may not be</span>
<span class="sd">        conformant with the DICOM File Format).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str or file-like</span>
<span class="sd">            Name of file or the file-like to write the new DICOM file to.</span>
<span class="sd">        write_like_original : bool</span>
<span class="sd">            If True (default), preserves the following information from</span>
<span class="sd">            the Dataset (and may result in a non-conformant file):</span>
<span class="sd">            - preamble -- if the original file has no preamble then none will</span>
<span class="sd">                be written.</span>
<span class="sd">            - file_meta -- if the original file was missing any required File</span>
<span class="sd">                Meta Information Group elements then they will not be added or</span>
<span class="sd">                written.</span>
<span class="sd">                If (0002,0000) &#39;File Meta Information Group Length&#39; is present</span>
<span class="sd">                then it may have its value updated.</span>
<span class="sd">            - seq.is_undefined_length -- if original had delimiters, write them</span>
<span class="sd">                now too, instead of the more sensible length characters</span>
<span class="sd">            - is_undefined_length_sequence_item -- for datasets that belong to</span>
<span class="sd">                a sequence, write the undefined length delimiters if that is</span>
<span class="sd">                what the original had.</span>
<span class="sd">            If False, produces a file conformant with the DICOM File Format,</span>
<span class="sd">            with explicit lengths for all elements.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pydicom.filewriter.write_dataset</span>
<span class="sd">            Write a DICOM Dataset to a file.</span>
<span class="sd">        pydicom.filewriter.write_file_meta_info</span>
<span class="sd">            Write the DICOM File Meta Information Group elements to a file.</span>
<span class="sd">        pydicom.filewriter.dcmwrite</span>
<span class="sd">            Write a DICOM file from a FileDataset instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure is_little_endian and is_implicit_VR are set</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_little_endian</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_implicit_VR</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;</span><span class="si">{0}</span><span class="s2">.is_little_endian&#39; and &#39;</span><span class="si">{0}</span><span class="s2">.is_implicit_VR&#39; must be &quot;</span>
                <span class="s2">&quot;set appropriately before saving.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

        <span class="n">pydicom</span><span class="o">.</span><span class="n">dcmwrite</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">write_like_original</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dataset.ensure_file_meta"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.ensure_file_meta">[docs]</a>    <span class="k">def</span> <span class="nf">ensure_file_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an empty file meta dataset if none exists.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_meta</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;file_meta&#39;</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">())</span></div>

<div class="viewcode-block" id="Dataset.fix_meta_info"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.fix_meta_info">[docs]</a>    <span class="k">def</span> <span class="nf">fix_meta_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">enforce_standard</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ensure the file meta info exists and has the correct values</span>
<span class="sd">        for transfer syntax and media storage uids.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The transfer syntax for is_implicit_VR = False and</span>
<span class="sd">            is_little_endian = True is ambiguous and will therefore not be set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        enforce_standard : boolean</span>
<span class="sd">            If True, a check for incorrect and missing elements is performed.</span>
<span class="sd">            (see pydicom.filewriter.validate_file_meta)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ensure_file_meta</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_little_endian</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_implicit_VR</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_meta</span><span class="o">.</span><span class="n">TransferSyntaxUID</span> <span class="o">=</span> <span class="n">ImplicitVRLittleEndian</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_little_endian</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_implicit_VR</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_meta</span><span class="o">.</span><span class="n">TransferSyntaxUID</span> <span class="o">=</span> <span class="n">ExplicitVRBigEndian</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_little_endian</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_implicit_VR</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Implicit VR Big Endian is not a &quot;</span>
                                      <span class="s2">&quot;supported Transfer Syntax.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;SOPClassUID&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_meta</span><span class="o">.</span><span class="n">MediaStorageSOPClassUID</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SOPClassUID</span>
        <span class="k">if</span> <span class="s1">&#39;SOPInstanceUID&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_meta</span><span class="o">.</span><span class="n">MediaStorageSOPInstanceUID</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SOPInstanceUID</span>
        <span class="k">if</span> <span class="n">enforce_standard</span><span class="p">:</span>
            <span class="n">validate_file_meta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_meta</span><span class="p">,</span> <span class="n">enforce_standard</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Intercept any attempts to set a value for an instance attribute.</span>

<span class="sd">        If name is a DICOM keyword, set the corresponding tag and DataElement.</span>
<span class="sd">        Else, set an instance (python) attribute as any other class would do.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            The element keyword for the DataElement you wish to add/change. If</span>
<span class="sd">            `name` is not a DICOM element keyword then this will be the</span>
<span class="sd">            name of the attribute to be added/changed.</span>
<span class="sd">        value</span>
<span class="sd">            The value for the attribute to be added/changed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">tag_for_keyword</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># successfully mapped name to a tag</span>
            <span class="k">if</span> <span class="n">tag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="c1"># don&#39;t have this tag yet-&gt;create the data_element instance</span>
                <span class="n">VR</span> <span class="o">=</span> <span class="n">dictionary_VR</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
                <span class="n">data_element</span> <span class="o">=</span> <span class="n">DataElement</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">VR</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">VR</span> <span class="o">==</span> <span class="s1">&#39;SQ&#39;</span><span class="p">:</span>
                    <span class="c1"># let a sequence know its parent dataset to pass it</span>
                    <span class="c1"># to its items, who may need parent dataset tags</span>
                    <span class="c1"># to resolve ambiguous tags</span>
                    <span class="n">data_element</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># already have this data_element, just changing its value</span>
                <span class="n">data_element</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
                <span class="n">data_element</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
            <span class="c1"># Now have data_element - store it in this dict</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_element</span>
        <span class="k">elif</span> <span class="n">repeater_has_keyword</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="c1"># Check if `name` is repeaters element</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is a DICOM repeating group &#39;</span>
                             <span class="s1">&#39;element and must be added using &#39;</span>
                             <span class="s1">&#39;the add() or add_new() methods.&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># name not in dicom dictionary - setting a non-dicom instance</span>
            <span class="c1"># attribute</span>
            <span class="c1"># XXX note if user mis-spells a dicom data_element - no error!!!</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Operator for Dataset[key] = value.</span>

<span class="sd">        Check consistency, and deal with private tags.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : int</span>
<span class="sd">            The tag for the element to be added to the Dataset.</span>
<span class="sd">        value : pydicom.dataelem.DataElement or pydicom.dataelem.RawDataElement</span>
<span class="sd">            The element to add to the Dataset.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            If `key` is a slice.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the `key` value doesn&#39;t match DataElement.tag.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Slicing is not supported for setting &#39;</span>
                                      <span class="s1">&#39;Dataset elements.&#39;</span><span class="p">)</span>

        <span class="c1"># OK if is subclass, e.g. DeferredDataElement</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">DataElement</span><span class="p">,</span> <span class="n">RawDataElement</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Dataset contents must be DataElement instances.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">BaseTag</span><span class="p">):</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">tag</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="n">Tag</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="n">tag</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DataElement.tag must match the dictionary key&quot;</span><span class="p">)</span>

        <span class="n">data_element</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="n">tag</span><span class="o">.</span><span class="n">is_private</span><span class="p">:</span>
            <span class="c1"># See PS 3.5-2008 section 7.8.1 (p. 44) for how blocks are reserved</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Setting private tag </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">tag</span><span class="p">)</span>
            <span class="n">private_block</span> <span class="o">=</span> <span class="n">tag</span><span class="o">.</span><span class="n">elem</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span>
            <span class="n">private_creator_tag</span> <span class="o">=</span> <span class="n">Tag</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">group</span><span class="p">,</span> <span class="n">private_block</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">private_creator_tag</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="n">tag</span> <span class="o">!=</span> <span class="n">private_creator_tag</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data_element</span><span class="o">.</span><span class="n">is_raw</span><span class="p">:</span>
                    <span class="n">data_element</span> <span class="o">=</span> <span class="n">DataElement_from_raw</span><span class="p">(</span>
                        <span class="n">data_element</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_character_set</span><span class="p">)</span>
                <span class="n">data_element</span><span class="o">.</span><span class="n">private_creator</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">private_creator_tag</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_element</span>

    <span class="k">def</span> <span class="nf">_slice_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the element tags in the Dataset that match the slice.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int or 2-tuple of int or None</span>
<span class="sd">            The slice&#39;s starting element tag value, in any format accepted by</span>
<span class="sd">            pydicom.tag.Tag.</span>
<span class="sd">        stop : int or 2-tuple of int or None</span>
<span class="sd">            The slice&#39;s stopping element tag value, in any format accepted by</span>
<span class="sd">            pydicom.tag.Tag.</span>
<span class="sd">        step : int or None</span>
<span class="sd">            The slice&#39;s step size.</span>

<span class="sd">        Returns</span>
<span class="sd">        ------</span>
<span class="sd">        list of pydicom.tag.Tag</span>
<span class="sd">            The tags in the Dataset that meet the conditions of the slice.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check the starting/stopping Tags are valid when used</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">Tag</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">Tag</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span>

        <span class="n">all_tags</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># If the Dataset is empty, return an empty list</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">all_tags</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># Special case the common situations:</span>
        <span class="c1">#   - start and/or stop are None</span>
        <span class="c1">#   - step is 1</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># For step=1 avoid copying the list</span>
                <span class="k">return</span> <span class="n">all_tags</span> <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">all_tags</span><span class="p">[::</span><span class="n">step</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Have a stop value, get values until that point</span>
                <span class="n">step1_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">takewhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">,</span> <span class="n">all_tags</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">step1_list</span> <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">step1_list</span><span class="p">[::</span><span class="n">step</span><span class="p">]</span>

        <span class="c1"># Have a non-None start value.  Find its index</span>
        <span class="n">i_start</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">all_tags</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">all_tags</span><span class="p">[</span><span class="n">i_start</span><span class="p">::</span><span class="n">step</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i_stop</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">all_tags</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">all_tags</span><span class="p">[</span><span class="n">i_start</span><span class="p">:</span><span class="n">i_stop</span><span class="p">:</span><span class="n">step</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handle str(dataset).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pretty_str</span><span class="p">()</span>

<div class="viewcode-block" id="Dataset.top"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.top">[docs]</a>    <span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a str of the Dataset&#39;s top level DataElements only.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pretty_str</span><span class="p">(</span><span class="n">top_level_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dataset.trait_names"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.trait_names">[docs]</a>    <span class="k">def</span> <span class="nf">trait_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of valid names for auto-completion code.</span>

<span class="sd">        Used in IPython, so that data element names can be found and offered</span>
<span class="sd">        for autocompletion on the IPython command line.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># only valid python &gt;=2.6, else use self.__dir__()</span></div>

<div class="viewcode-block" id="Dataset.update"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extend dict.update() to handle DICOM keywords.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dictionary : dict or Dataset</span>
<span class="sd">            The dict or Dataset to use when updating the current object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">dictionary</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">compat</span><span class="o">.</span><span class="n">text_type</span><span class="p">)):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">Tag</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span></div>

<div class="viewcode-block" id="Dataset.iterall"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.iterall">[docs]</a>    <span class="k">def</span> <span class="nf">iterall</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate through the Dataset, yielding all DataElements.</span>

<span class="sd">        Unlike Dataset.__iter__, this *does* recurse into sequences,</span>
<span class="sd">        and so returns all data elements as if the file were &quot;flattened&quot;.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        pydicom.dataelem.DataElement</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">data_element</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">data_element</span>
            <span class="k">if</span> <span class="n">data_element</span><span class="o">.</span><span class="n">VR</span> <span class="o">==</span> <span class="s2">&quot;SQ&quot;</span><span class="p">:</span>
                <span class="n">sequence</span> <span class="o">=</span> <span class="n">data_element</span><span class="o">.</span><span class="n">value</span>
                <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">iterall</span><span class="p">():</span>
                        <span class="k">yield</span> <span class="n">elem</span></div>

<div class="viewcode-block" id="Dataset.walk"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.Dataset.walk">[docs]</a>    <span class="k">def</span> <span class="nf">walk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate through the DataElements and run `callback` on each.</span>

<span class="sd">        Visit all DataElements, possibly recursing into sequences and their</span>
<span class="sd">        datasets. The callback function is called for each DataElement</span>
<span class="sd">        (including SQ element). Can be used to perform an operation on certain</span>
<span class="sd">        types of DataElements. E.g., `remove_private_tags`() finds all private</span>
<span class="sd">        tags and deletes them. DataElement`s will come back in DICOM order (by</span>
<span class="sd">        increasing tag number within their dataset).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        callback</span>
<span class="sd">            A callable that takes two arguments:</span>
<span class="sd">                * a Dataset</span>
<span class="sd">                * a DataElement belonging to that Dataset</span>
<span class="sd">        recursive : bool</span>
<span class="sd">            Flag to indicate whether to recurse into Sequences.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">taglist</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">taglist</span><span class="p">:</span>

            <span class="k">with</span> <span class="n">tag_in_exception</span><span class="p">(</span><span class="n">tag</span><span class="p">):</span>
                <span class="n">data_element</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
                <span class="n">callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_element</span><span class="p">)</span>  <span class="c1"># self = this Dataset</span>
                <span class="c1"># &#39;tag in self&#39; below needed in case callback deleted</span>
                <span class="c1"># data_element</span>
                <span class="k">if</span> <span class="n">recursive</span> <span class="ow">and</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="n">data_element</span><span class="o">.</span><span class="n">VR</span> <span class="o">==</span> <span class="s2">&quot;SQ&quot;</span><span class="p">:</span>
                    <span class="n">sequence</span> <span class="o">=</span> <span class="n">data_element</span><span class="o">.</span><span class="n">value</span>
                    <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
                        <span class="n">dataset</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span></div>

    <span class="fm">__repr__</span> <span class="o">=</span> <span class="fm">__str__</span></div>


<div class="viewcode-block" id="FileDataset"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.FileDataset">[docs]</a><span class="k">class</span> <span class="nc">FileDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An extension of Dataset to make reading and writing to file-like easier.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    preamble : str or bytes or None</span>
<span class="sd">        The optional DICOM preamble prepended to the dataset, if available.</span>
<span class="sd">    file_meta : pydicom.dataset.Dataset or None</span>
<span class="sd">        The Dataset&#39;s file meta information as a Dataset, if available (None if</span>
<span class="sd">        not present). Consists of group 0002 elements.</span>
<span class="sd">    filename : str or None</span>
<span class="sd">        The filename that the dataset was read from (if read from file) or None</span>
<span class="sd">        if the filename is not available (if read from a BytesIO or similar).</span>
<span class="sd">    fileobj_type</span>
<span class="sd">        The object type of the file-like the Dataset was read from.</span>
<span class="sd">    is_implicit_VR : bool</span>
<span class="sd">        True if the dataset encoding is implicit VR, False otherwise.</span>
<span class="sd">    is_little_endian : bool</span>
<span class="sd">        True if the dataset encoding is little endian byte ordering, False</span>
<span class="sd">        otherwise.</span>
<span class="sd">    timestamp : float or None</span>
<span class="sd">        The modification time of the file the dataset was read from, None if</span>
<span class="sd">        the modification time is not available.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">filename_or_obj</span><span class="p">,</span>
                 <span class="n">dataset</span><span class="p">,</span>
                 <span class="n">preamble</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">file_meta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">is_implicit_VR</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">is_little_endian</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a Dataset read from a DICOM file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename_or_obj : str or BytesIO or None</span>
<span class="sd">            Full path and filename to the file, memory buffer object, or None</span>
<span class="sd">            if is a BytesIO.</span>
<span class="sd">        dataset : Dataset or dict</span>
<span class="sd">            Some form of dictionary, usually a Dataset from read_dataset().</span>
<span class="sd">        preamble : bytes or str, optional</span>
<span class="sd">            The 128-byte DICOM preamble.</span>
<span class="sd">        file_meta : Dataset, optional</span>
<span class="sd">            The file meta info dataset, as returned by _read_file_meta,</span>
<span class="sd">            or an empty dataset if no file meta information is in the file.</span>
<span class="sd">        is_implicit_VR : bool, optional</span>
<span class="sd">            True (default) if implicit VR transfer syntax used; False if</span>
<span class="sd">            explicit VR.</span>
<span class="sd">        is_little_endian : boolean</span>
<span class="sd">            True (default) if little-endian transfer syntax used; False if</span>
<span class="sd">            big-endian.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Dataset</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preamble</span> <span class="o">=</span> <span class="n">preamble</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_meta</span> <span class="o">=</span> <span class="n">file_meta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_implicit_VR</span> <span class="o">=</span> <span class="n">is_implicit_VR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_little_endian</span> <span class="o">=</span> <span class="n">is_little_endian</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename_or_obj</span><span class="p">,</span> <span class="n">compat</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename_or_obj</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fileobj_type</span> <span class="o">=</span> <span class="nb">open</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename_or_obj</span><span class="p">,</span> <span class="n">io</span><span class="o">.</span><span class="n">BufferedReader</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename_or_obj</span><span class="o">.</span><span class="n">name</span>
            <span class="c1"># This is the appropriate constructor for io.BufferedReader</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fileobj_type</span> <span class="o">=</span> <span class="nb">open</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># use __class__ python &lt;2.7?;</span>
            <span class="c1"># http://docs.python.org/reference/datamodel.html</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fileobj_type</span> <span class="o">=</span> <span class="n">filename_or_obj</span><span class="o">.</span><span class="vm">__class__</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">filename_or_obj</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename_or_obj</span><span class="o">.</span><span class="n">name</span>
            <span class="k">elif</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">filename_or_obj</span><span class="p">,</span> <span class="s2">&quot;filename&quot;</span><span class="p">,</span>
                         <span class="kc">False</span><span class="p">):</span>  <span class="c1"># gzip python &lt;2.7?</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename_or_obj</span><span class="o">.</span><span class="n">filename</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># e.g. came from BytesIO or something file-like</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">):</span>
            <span class="n">statinfo</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">statinfo</span><span class="o">.</span><span class="n">st_mtime</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compare `self` and `other` for equality.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            The result if `self` and `other` are the same class</span>
<span class="sd">        NotImplemented</span>
<span class="sd">            If `other` is not the same class as `self` then returning</span>
<span class="sd">            NotImplemented delegates the result to superclass.__eq__(subclass)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># When comparing against self this will be faster</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">_dict_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="n">_dict_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">,</span>
                                <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_dict&#39;</span><span class="p">])</span>
                    <span class="p">)</span>

        <span class="k">return</span> <span class="bp">NotImplemented</span></div>


<div class="viewcode-block" id="validate_file_meta"><a class="viewcode-back" href="../../api_ref.html#pydicom.dataset.validate_file_meta">[docs]</a><span class="k">def</span> <span class="nf">validate_file_meta</span><span class="p">(</span><span class="n">file_meta</span><span class="p">,</span> <span class="n">enforce_standard</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Validates the File Meta Information elements in `file_meta` and</span>
<span class="sd">    adds some tags if missing and `enforce_standard` is True.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    file_meta : pydicom.dataset.Dataset</span>
<span class="sd">        The File Meta Information data elements.</span>
<span class="sd">    enforce_standard : bool</span>
<span class="sd">        If False, then only a check for invalid elements is performed.</span>
<span class="sd">        If True, the following elements will be added if not already present:</span>
<span class="sd">            * (0002,0001) FileMetaInformationVersion</span>
<span class="sd">            * (0002,0012) ImplementationClassUID</span>
<span class="sd">            * (0002,0013) ImplementationVersionName</span>
<span class="sd">        and the following elements will be checked:</span>
<span class="sd">            * (0002,0002) MediaStorageSOPClassUID</span>
<span class="sd">            * (0002,0003) MediaStorageSOPInstanceUID</span>
<span class="sd">            * (0002,0010) TransferSyntaxUID</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `enforce_standard` is True and any of the checked File Meta</span>
<span class="sd">        Information elements are missing from `file_meta`.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If any non-Group 2 Elements are present in `file_meta`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check that no non-Group 2 Elements are present</span>
    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">file_meta</span><span class="o">.</span><span class="n">elements</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">elem</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">group</span> <span class="o">!=</span> <span class="mh">0x0002</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only File Meta Information Group (0002,eeee) &quot;</span>
                             <span class="s2">&quot;elements must be present in &#39;file_meta&#39;.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">enforce_standard</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;FileMetaInformationVersion&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">file_meta</span><span class="p">:</span>
            <span class="n">file_meta</span><span class="o">.</span><span class="n">FileMetaInformationVersion</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00\x01</span><span class="s1">&#39;</span>

        <span class="k">if</span> <span class="s1">&#39;ImplementationClassUID&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">file_meta</span><span class="p">:</span>
            <span class="n">file_meta</span><span class="o">.</span><span class="n">ImplementationClassUID</span> <span class="o">=</span> <span class="n">PYDICOM_IMPLEMENTATION_UID</span>

        <span class="k">if</span> <span class="s1">&#39;ImplementationVersionName&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">file_meta</span><span class="p">:</span>
            <span class="n">file_meta</span><span class="o">.</span><span class="n">ImplementationVersionName</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s1">&#39;PYDICOM &#39;</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">__version_info__</span><span class="p">))</span>

        <span class="c1"># Check that required File Meta Information elements are present</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="p">[</span><span class="mh">0x0002</span><span class="p">,</span> <span class="mh">0x0003</span><span class="p">,</span> <span class="mh">0x0010</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">Tag</span><span class="p">(</span><span class="mh">0x0002</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">file_meta</span><span class="p">:</span>
                <span class="n">missing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Tag</span><span class="p">(</span><span class="mh">0x0002</span><span class="p">,</span> <span class="n">element</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Missing required File Meta Information elements from &quot;</span>
                   <span class="s2">&quot;&#39;file_meta&#39;:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">missing</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">keyword_for_tag</span><span class="p">(</span><span class="n">tag</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Remove final newline</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2008-2019, Darcy Mason and pydicom contributors

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>